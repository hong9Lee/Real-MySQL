# ***파티션***  

## `파티션을 사용하는 이유`  
테이블은 논리적으로는 하나의 테이블이지만 물리적으로 여러개의 소규모 테이블로 분산하여 관리할 수 있게 해준다.  

## `어떨때?`  
하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등에 사용.  
데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어준다.  


## `이력 데이터의 효율적인 관리`  
로그 데이터의 경우 라이프 사이클이 상당히 짧다.  
로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단하고 빠르게 해결 가능하다.  

```
X
ALTER TABLE DROP PARTITION...
2007년 파티션 

2008년 파티션 2009년 파티션...

+
ALTER TABLE ADD PARTITION...
2011년 파티션
```

## `파티션의 내부 처리`  

#### INSERT  
INSERT 쿼리가 실행되면 MYSQL 서버는 INSERT 되는 컬럼의 값 중에서 파티션의 키를 이용해 파티션 표현식을 평가하고,  
그 결과를 이용해 레코드가 저장될 적절한 파티션을 결정한다.  

#### UPDATE  
UPDATE 쿼리를 실행하려면 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾아야 한다.  
- 파티션 키 이외의 컬럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 컬럼 값만 변경한다.  
- 파티션 키 컬럼이 변경될 때는 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제한다.  그리고 변경되는 파티션 키 컬럼의 표현식을 평가하고, 그 결과를 이용해 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 새로 저장한다.  

## `파티션 테이블의 검색`  
파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건  
- WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?  
- WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔) 할 수 있는가?  

가능한 한, 파티션 선택과 인덱스 효율적 사용 가능 둘중 하나 이상은 만족하는 것이 좋다.  

## `파티션 테이블의 인덱스 스캔과 정렬`  
테이블에서 인덱스 스캔을 통해 레코드를 읽을때 MYSQL 서버가 별도의 정렬 작업을 수행하지는 않는다.  
하지만, 일반 테이블의 인덱스 스캔처럼 결과를 바로 반환하는 것이 아니라 내부적으로 큐(우선순위 큐) 처리가 한 번 필요한 것이다.  

## `파티션 프루닝`  
옵티마이저에 의해 3개의 파티션 가운데 2개만 읽어도 된다고 판단되면 불필요한 파티션에는 전혀 접근하지 않는다.  
이렇게 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 파티션 프루닝 이라고 한다.  
