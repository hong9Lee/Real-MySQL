# ***파티션***  

## `파티션을 사용하는 이유`  
테이블은 논리적으로는 하나의 테이블이지만 물리적으로 여러개의 소규모 테이블로 분산하여 관리할 수 있게 해준다.  

## `어떨때?`  
하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등에 사용.  
데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어준다.  


## `이력 데이터의 효율적인 관리`  
로그 데이터의 경우 라이프 사이클이 상당히 짧다.  
로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단하고 빠르게 해결 가능하다.  

```
X
ALTER TABLE DROP PARTITION...
2007년 파티션 

2008년 파티션 2009년 파티션...

+
ALTER TABLE ADD PARTITION...
2011년 파티션
```

## `파티션의 내부 처리`  

#### INSERT  
INSERT 쿼리가 실행되면 MYSQL 서버는 INSERT 되는 컬럼의 값 중에서 파티션의 키를 이용해 파티션 표현식을 평가하고,  
그 결과를 이용해 레코드가 저장될 적절한 파티션을 결정한다.  

#### UPDATE  
UPDATE 쿼리를 실행하려면 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾아야 한다.  
- 파티션 키 이외의 컬럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 컬럼 값만 변경한다.  
- 파티션 키 컬럼이 변경될 때는 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제한다.  그리고 변경되는 파티션 키 컬럼의 표현식을 평가하고, 그 결과를 이용해 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 새로 저장한다.  

## `파티션 테이블의 검색`  
파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건  
- WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?  
- WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔) 할 수 있는가?  

가능한 한, 파티션 선택과 인덱스 효율적 사용 가능 둘중 하나 이상은 만족하는 것이 좋다.  

## `파티션 테이블의 인덱스 스캔과 정렬`  
테이블에서 인덱스 스캔을 통해 레코드를 읽을때 MYSQL 서버가 별도의 정렬 작업을 수행하지는 않는다.  
하지만, 일반 테이블의 인덱스 스캔처럼 결과를 바로 반환하는 것이 아니라 내부적으로 큐(우선순위 큐) 처리가 한 번 필요한 것이다.  

## `파티션 프루닝`  
옵티마이저에 의해 3개의 파티션 가운데 2개만 읽어도 된다고 판단되면 불필요한 파티션에는 전혀 접근하지 않는다.  
이렇게 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 파티션 프루닝 이라고 한다.  

## `파티션 주의사항`  
```
CREATE TABLE tb_article (
article_id INT NOT NULL AUTO_INCREMENT,
reg_date DATETIME NOT NULL,
...
PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE ( YEAR(reg_date) ) (
    PARTITION p2009 VALUES LESS THAN (2010),
    ...
);
```  

- 스토어드 루틴, UDF, 사용자 변수 등을 파티션 표현식에 사용할 수 없다.  
- 일부 함수들은 파티션 생성은 가능하지만 파티션 프루닝을 지원하지 않을 수 있다.  
- 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 컬럼을 포함해야 한다.  
- 파티션된 테이블의 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있다. 또한 파티션 개별로 인덱스를 변경하거나 추가할 수 없다.  
- 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있다.  
- 최대 8192개의 파티션을 가질 수 있다.  
- 파티션 테이블에서는 외래키를 사용할 수 없다.  
- 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없다.  
- 공간 데이터를 저장하는 컬럼 타입은 사용할 수 없다.  
- 임시 테이블은 파티션 기능을 사용할 수 없다.  


## `파티션과 유니크 키`  
종류와 관계없이 테이블에 유니크 인덱스가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 컬럼을 포함해야 한다.  

```
CREATE TABLE tb_partition (
    fd1 INT NOT NULL,
    fd2 INT NOT NULL,
    fd3 INT NOT NULL,
    UNIQUE KEY (fd1, fd2, fd3)
    ) PARTITION BY HASH(fd1)
    PARTITIONS 4;

CREATE TABLE tb_partition (
    fd1 INT NOT NULL,
    fd2 INT NOT NULL,
    fd3 INT NOT NULL,
    UNIQUE KEY (fd1, fd2)
    ) PARTITION BY HASH(fd1 + fd2)
    PARTITIONS 4;
    
CREATE TABLE tb_partition (
    fd1 INT NOT NULL,
    fd2 INT NOT NULL,
    fd3 INT NOT NULL,
    UNIQUE KEY (fd1, fd2, fd3),
    UNIQUE KEY (fd3)
    ) PARTITION BY HASH(fd3)
    PARTITIONS 4;
```  

## `파티션의 종류`  

#### 레인지 파티션  
파티션 키의 연속된 범위로 파티션을 정의하는 방법으로, 가장 일반적인 파티션이다.  

`용도`  
- 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할때.  
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때.  
- 파티션 키 위주로 검색이 자주 실행될 때.  

DB에서 파티션의 장점은 두가지 이다.  
- 큰 테이블을 작은 크기의 파티션으로 분리.  
- 필요한 파티션만 접근(쓰기와 읽기 모두)  

파티션의 기본 조건은 하나의 레코드는 반드시 하나의 파티션에만 저장돼야 한다.  
만약 새로운 파티션을 더 추가하게 된다면, ALTER TABLE... REORGANIZE PARTITION 명령을 사용해야 한다.  
기존 파티션을 분리, 병합할때도 사용되며, INPLACE 알고리즘을 사용할 수 있지만 최소한 읽기 잠금(Shared Lock)이 필요하다.  
파티션이 재구성 되는 동안은 테이블의 쓰기가 불가능해지므로 파티션 재구성 작업은 서비스 점검 시간대나 쿼리 처리가 많지 않은 시간대에 진행하는 것이 좋다.  

#### 리스트 파티션  
레인지 파티션과 유사하지만, 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다.  
MAXVALUE 파티션을 사용할 수 없다.  

`용도`  
- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때  
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때  
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때  

```
CREATE TABLE product(
    id INT NOT NULL,
    name VARCHAR(30),
    category_id INT NOT NULL,
    ...
    )
    PARTITION BY LIST(category_id) (
    PARTITION p_application VALUES IN (3),
    PARTITION p_sports VALUES IN (2, 6, 7),
    PARTITION p_etc VALUES IN (4, 5, 8, NULL),
```



