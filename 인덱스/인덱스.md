## ***INDEX***
  
대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.  

- B-Tree 인덱스
컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘.  
- Hash 인덱스  
컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.  
값을 변형해서 인덱싱 하기 때문에 전방일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.  



  
##### `B-Tree 인덱스`  
컬럼의 값을 변형하지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.  
루트 노드 - 브랜치 노드 - 리프 노드 형태이다.  

`인덱스 키 추가`  
저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색한다.  
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장한다.  
리프 노드가 꽉 차서 더는 저장할 수 없을 때 리프 노드가 분리 되어야 한다.  
이러한 작업 탓에 상대적으로 쓰기 작업에 비용이 많이 든다.  

`인덱스 키 삭제`  
해당 키 값이 저장된 리프노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.  

`인덱스 키 변경`  
인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우 인덱스상의 키 값만 변경하는 것은 불가능하다.  
키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.  

`인덱스 키 검색`  
인덱스의 검색이란 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드 까지 이동하면서 비교 작업을 수행하는데,  
이를 "트리 탐색" 이라고 한다.  
B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값을 앞 부분만 일치하는 경우에 사용할 수 있다.  
부등호 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.  

`인덱스 키 값의 크기`  
디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.  
인덱스는 페이지 단위로 관리된다.  
노드를 구분하는 기준이 페이지 단위이다.  
MySQL의 B-Tree는 자식 노드의 갯수가 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.    
인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어날 수 있다. (기본 16KB)  

`B-Tree 깊이`  
B-Tree의 깊이는 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.  

`선택도`  
인덱스에서 선택도 혹은 기수성은 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.  
선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.  

`읽어야 하는 레코드의 건수`  
인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.  

`B-Tree를 통한 데이터 읽기`  
어떤 경우에 인덱스를 사용하게 유도할지, 하용하지 못하게 할지 판단하려면 MySQL이 인덱스를 이용하는 대표적인 방법 세가지를 알아야 한다.  

`인덱스 레인지 스캔`  
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.  
일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.  
루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향(오름 or 내림차순)으로 인덱스를 읽어 나가는 과정이다.  
어떤 방식이던, 컬럼의 정순 혹은 역순으로 데이터를 가져온다는게 중요하다.  
스캔한 레코드 한건 한건 단위로 랜덤 I/O가 한 번씩 일어난다.  
I/O 과정은 데이터에 따라 필요하지 않을 수 있는데, 이를 커버링 인덱스라고 한다.  

`인덱스 풀 스캔`  
인덱스의 처음부터 끝까지 모두 읽는 방식이다.  
대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.  
인덱스는 (A, B, C)로 만들ㄹ어져 있지만 쿼리의 조건절은 B or C 컬럼으로 검색하는 경우이다.  
보통 인덱스 풀 스캔은 테이블 풀 스캔보다 빠르다.  

`루스 인덱스 스캔`  
필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태이다.  
일반적으로 GROUP BY나 집합 함수 가운에 MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용된다.  

```
SELECT detp_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```  
dept_emp 테이블은 dept_no와 emp_no라는 두개의 컬럼으로 인덱스가 생성되어 있다.    
또한 dept_no, emp_no 조합으로 정렬까지 돼 있어서 dept_no 그룹 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.  
이러한 경우, WHERE 조건을 만족하는 범위 전체를 다 스캔할 필요 없이 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다.  

`인덱스 스킵 스캔`  
인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다.  

```  
ALTER TABLE employees
    ADD INDEX ix_gender_birthdate(gender, birth_date);
    
// 인덱스를 사용하지 못하는 쿼리
SELECT * FROM employees WHERE birth_date >= '';
// 인덱스를 사용할 수 있는 쿼리
SELECT * FROM employees WHERE gender='M' AND birth_date >= '';
```   
MYSQL 8.0 부터는 옵티마이저가 gender 컬럼을 건너 뛰어서 birth_date 컬럼 만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.  
스킵 스캔의 경우 MYSQL 옵티마이저는 우선 gender 컬럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 컬럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.  
하지만 여기에도 주의할 점이 존재한다.  
- WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함.  
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)  

첫번째 조건은 유니크한 값의 개수가 매우 많다면 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다.  

`다중 컬럼 인덱스`  
두 개 이상의 컬럼으로 구성된 인덱스이다.  
중요한 점은, 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬돼 있다.  
따라서 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치가 상당히 중요하다.  

`B-Tree 인덱스의 정렬 및 스캔 방향`  
인덱스를 생성할 때, 설정한 정렬 규칙에 따라 인덱스의 키 값은 항상 오름/내림 차순으로 정렬되어 저장된다.  
인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.  

`인덱스의 정렬`  
인덱스를 생성하는 시점에 인덱스를 구성하는 각 컬럼의 정렬을 오름/내림 차순으로 설정할 수 있다.  
아래와 같이 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다.  
```
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

`인덱스 스캔 방향`  
아래 쿼리는 처음부터 오름차순으로 끝까지 읽어 first_name이 가장 큰 값 하나를 가져오는 것일까?  
```
SELECT *
FROM employees
ORDER BY first_name DESC
LIMIT 1;
```

그렇지 않다.  인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최솟값부터 읽으면 오름차순으로 값을 가져올 수 있고,  
최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다.  
위의 쿼리는 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다.  
  
즉, 인덱스 생성 시점에 오름/내림 차순으로 정렬이 결정되지만, 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름/내림 차순 정렬 효과를 얻을 수 있다.  


```  
SELECT * FROM employees WHERE first_name >= 'Anneke'
ORDER BY first_name ASC LIMIT 4;


SELECT * FROM employees
ORDER BY first_name DESC LIMIT 5;
```
위의 첫 번째 쿼리는 first_name 컬럼에 정의된 인덱스를 이용해 Anneke라는 레코드를 찾은 후,  
정순으로 해당 인덱스를 읽으면서 4개의 레코드만 가져오면 아무런 비용을 들이지 않고도 원하는 정렬 효과를 얻을 수 있다.  

두번째 쿼리는 first_name 컬럼에 정의된 인덱스를 역순으로 읽으면서 처음 다섯 개의 레코드만 가져오면 된다.  

`내림차순 인덱스`  
인덱스 생성 시 지정한 방향대로 읽는 것이 정순 스캔, 반대로 읽는 것이 역순 스캔이다.    
인덱스 역순 스캔은 정순 스캔에 비해 느릴 수 밖에 없다.  
이유는 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조이기 때문이다.  

`B-Tree 인덱스의 가용성과 효율성`  
다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 동등 비교인지 아니면 크다 또는 작다 같은 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라지며,  
그 효율 또한 달라진다.  

```
SELECT * FROM dept_emp  
WHERE dept_no='d002' AND emp_no >= 10114;

CASE A: INDEX(dept_no, emp_no)
-> 이 경우 dept_no='d002' AND emp_no>=10114인 레코드를 찾고, 이후에는 dept_no가 d002가 아닐 때까지 인덱스를 그냥 쭉 읽기만 한다.
CASE B: INDEX(emp_no, dept_no)
-> 이 경우 emp_no>=10114 AND dept_no='d002'인 경우를 찾고 그 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교하는 과정을 거쳐야 한다.
```
이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링 이라고 한다.  
위의 예제는 다중 컬럼 인덱스의 정렬방식( 인덱스의 N번쨰 키 값은 N-1번째 키 값에 대해서 다시 정렬됨) 때문이다.  
공식적인 명칭은 아니지만 A 조건을 작업 범위 결정 조건이라고 하고,  
B 조건을 필터링 조건 또는 체크 조건 이라고 표현한다.  
`작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 그다지...`


`인덱스의 가용성`  
B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다는 것이다.  
이러한 정렬 특성은 빠른 검색의 전제 조건이다.  
또한, 다중 컬럼 인덱스에서도 왼쪽 컬럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.  
CASE A: INDEX(first_name)  
CASE B: INDEX(dept_no, emp_no)  

```
SELECT * from employees WHERE first_name like '%mer%';

해당 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없다.  
first_name 컬럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상숫값에는 왼쪽 부분이 고정되지 않았기 때문이다.
따라서 정렬 우선순위가 낮은 뒷부분의 값만으로는 왼쪽 기준 정렬 기반의 인덱스의 효과를 얻을 수 없다.  
```  

```
SELECT * FROM dept_emp WHERE emp_no >= 10144;

인덱스가 (dept_no, emp_no) 컬럼 순서대로 생성돼 있다면 인덱스의 선행 컬럼인 dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.  
이유는 dept_no 컬럼에 대해 먼저 정렬한 후, emp_no 컬럼값으로 정렬돼 있기 때문이다.
```


`가용성과 효율성 판단`  
B-Tree 인덱스 특성상 아래 조건에서는 작업 범위 결정 조건으로 사용할 수 없다.  
- NOT-EQUAL로 비교된 경우
-> WHERE column <> 'N'
-> WHERE column NOT IN (10, 11)
-> WHERE column IS NOT NULL

- LIKE '%??' 앞 부분이 아닌 뒷부분 일치 형태로 문자열 패턴이 비교된 경우  
-> WHERE column LIKE '%XX'

- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우  
-> WHERE SUBSTRING(clumn,1,1) = 'X'  

- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우  
-> WHERE cloumn = deterministic_function();

- 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)  
-> WHERE char_column = 10  

- 문자열 데이터 타입의 콜레이션이 다른 경우  
-> WHERE utf8_bin_char_column = euckr_bin_char_column


다른 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MYSQL에서는 NULL 값도 인덱스에 저장된다.  

다중 컬럼 인덱스의 경우에는...  
```
INDEX ix_test(column_1, column_2, column_3,,, column_n)
```  

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
-> column_1 컬럼에 대한 조건이 없는 경우  
-> column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우  


- 작업 범위 결정 조건으로 인덱스를 사용하는 경우
-> column_1 ~ column_(i-1)  컬럼까지 동등 비교 형태 (= 또는 IN)로 비교  
-> column_i 컬럼에 대해 다음 연산자 중 하나로 비교  
동등 비교, 크다 작다 형태, LIKE로 좌측 일치 패턴  


`함수 기반 인덱스`  
일반적인 인덱스는 컬럼의 값 일부 또는 전체에 대해서만 인덱스 생성이 허용된다.  
하지만 컬럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 경우, 함수 기반의 인덱스를 활용하면 된다.  
- 가상 컬럼을 이용한 인덱스  
2개의 필드를 합쳐서 검색해야 하는 요건이 생겼다면 가상 컬럼에 인덱스를 생성할 수 있다.  
```
ALTER TABLE user
    add full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
    add INDEX ix_fullname(full_name);
```  
이는 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블 구조가 변경된다는 단점이 있다.  

- 함수를 이용한 인덱스  
함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들어준다.    
함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되어야 한다.  
```
CREATE TABLE user (
    ...
    INDEX ix_fullname ((CONCAT(first_name,' ',last_name)))
    
EXPLAIN SELECT * FROM user WHERE CONCAT(first_name,' ',last_name)='Matt Lee';    
```


`멀티 밸류 인덱스`  
대부분의 인덱스는 렠드 1건이 1개의 인덱스 키 값을 가진다.  
즉, 인덱스 키와 데이터 레코드는 1:1의 관계를 가진다.  
하지만 멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다.  
```
...
credit_info JSON,
...
INDEX mx_creditscores( (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)) )

INSERT INTO user VALUES (.... , '{"credit_scores":[360, 353, 351]}'
```
이러한 멀티 밸류 인덱스를 활용하기 위해서는 반드시 함수를 사용해야한다.  
```
SELECT * FROM user WHERE 360 MEMBER OF(credit_info->'$.credit_scores');
```

`클러스터링 인덱스`  
클러스터링이란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, MYSQL 서버에서 클러스터링은 테이블의 레코드를 비슷한것들끼리 묶어서 저장하는 형태이다.    
주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안한것.  
InnoDB에서만 지원한다.  

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용이 된다.  
프라이머리 키 값에 의해 레코드의 저장 위치가 결정되므로 알고리즘이라기 보다 테이블 레코드의 저장 방식이다.    
프라이머리 키 기반 검색이 매우 빠르며, 레코드의 저장이나 프라이머리 키 변경이 상대적으로 느리다.    

키 선택 
1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택  
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택  
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택  

장점
- 프라이머리 키로 검색할때 처리 성능이 매우 바르다.  
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음.

단점  
- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐.  
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림.  
- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림.  
- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림.  

프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다.    
프라이머리 키로 검색할 경우 매우 빠르게 처리되므로 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 설정하는 것이 좋다.  
로그 테이블과 같이 조회 보다는 INSERT 위주의 테이블들은 AUTO_INCREMENT를 이용한 식별자를 프라이머리 키로 설정하는 것이 좋다.  


`유니크 인덱스`  
인덱스라기보다는 제약 조건에 가깝다.  
테이블이나 인덱스에 같은 값이 저장될 수 없다.  
인덱스 읽기는 세컨더리 인덱스와 차이가 미미하다.  
하지만 쓰기 작업의 경우 중복된 값이 있는지 한번 체크해야 하기 때문에 더 느리다.  
세컨더리 인덱스와 복합으로 사용할 필요는 없다.  













