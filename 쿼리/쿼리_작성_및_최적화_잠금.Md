# ***쿼리 작성 및 최적화***  

## `잠금을 사용하는 SELECT`  
InnoDB 레코드를 SELECT 할때 아무런 잠금도 걸지 않는데, 이를 잠금 없는 읽기라고 한다.  
하지만, SELECT 쿼리를 이용해 읽은 레코드의 컬럼 값을 어플리케이션에서 가공해서 다시 업데이트하고자 할 때는  
SELECT 가 실행된 후 다른 트랜잭션이 그 컬럼의 값을 변경하지 못하게 해야 한다.  
이럴 때는 레코드를 읽으면서 강제로 잠금을 걸어 둘 필요가 있는데,  
이때 사용하는 옵션이 FOR SHARE와 FOR UPDATE 절이다.  
- FOR SHARE: SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 건다.  
    -> SELECT된 레코드에 대해 읽기 잠금(공유 잠금, Shared lock)을 설정하고 다른 세션에서 해당 레코드를 변경하지 못하게 한다. 물론 다른 세션에서 잠금이 걸린 레코드를 읽는 것은 가능하다.    
- FOR UPDATE: SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 건다.  
    -> 쓰기 잠금(배타 잠금, Exclusive lock)을 설정하고, 다른 트랜잭션에서는 그 레코드를 변경하는것 뿐만 아니라 읽기(FOR SHARE 절을 사용하는 SELECT 쿼리)도 수행할 수 없다.  

InnoDB에서는 테이블에서 잠금 없는 읽기가 지원되기 때문에 특정 레코드가 잠겨진 상태라 하더라도 단순 SELECT 쿼리는 아무런 대기 없이 실행된다.  

```  
세션-1                                            세션-2
BEGIN;

SELECT *                                         
FROM employees
WHERE emp_no=10001 FOR UPDATE;


                                                SELECT *
                                                FROM employees
                                                WHERE emp_no=10001;
                                                => 잠금 대기 없이 즉시 결과 반환
```


```
세션-1                                            세션-2
BEGIN;

SELECT *                                         
FROM employees
WHERE emp_no=10001 FOR UPDATE;


                                                SELECT *
                                                FROM employees
                                                WHERE emp_no=10001 FOR SHARE;
                                                => 세션-1의 잠금을 기다림


COMMIT;
                                                => SELECT 쿼리 결과 반환                                                                    
```


## `잠금 테이블 선택`  

```
SELECT *
FROM employees e
    INNER JOIN dept_emp de ON de.emp_no=e.emp_no
    INNER JOIN departments d ON d.dept_no=de.dept_no
FOR UPDATE;
```

위 쿼리는 3개의 테이블에서 읽은 레코드에 대해 모두 쓰기 잠금을 걸게 된다.  
조인된 테이블은 참고용으로만 읽고 employees 테이블에만 잠금을 걸고 싶다면 어떻게 해야할까?  
이러한 경우 "OF 테이블" 절을 사용하면 된다.  

```
SELECT *
FROM employees e
    INNER JOIN dept_emp de ON de.emp_no=e.emp_no
    INNER JOIN departments d ON d.dept_no=de.dept_no
WHERE e.emp_no=10001    
FOR UPDATE OF e;
```  

## `NOWAIT & SKIP LOCKED`  

```
BEGIN;
SELECT * FROM employees WHERE emp_no=10001 FOR UPDATE;
UPDATE employees SET ,,, WHERE emp_no=10001;
COMMIT;
```  
먼저 emp_no가 10001인 사원을 먼저 읽어서 연산한 후 테이블을 업데이트 한다.  
다른 트랜잭션이 접근할 경우, FOR UPDATE의 영향으로 변경 작업을 장시간 수행하고 있다면 트랜잭션이 완료될 때까지 기다려야 한다.  
또는, 시스템 변수에 설정된 시간 (default 50초) 동안 기다렸다가 에러 메시지를 받게 된다.  

