# ***쿼리 작성 및 최적화***  

## `잠금을 사용하는 SELECT`  
InnoDB 레코드를 SELECT 할때 아무런 잠금도 걸지 않는데, 이를 잠금 없는 읽기라고 한다.  
하지만, SELECT 쿼리를 이용해 읽은 레코드의 컬럼 값을 어플리케이션에서 가공해서 다시 업데이트하고자 할 때는  
SELECT 가 실행된 후 다른 트랜잭션이 그 컬럼의 값을 변경하지 못하게 해야 한다.  
이럴 때는 레코드를 읽으면서 강제로 잠금을 걸어 둘 필요가 있는데,  
이때 사용하는 옵션이 FOR SHARE와 FOR UPDATE 절이다.  
- FOR SHARE: SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 건다.  
    -> SELECT된 레코드에 대해 읽기 잠금(공유 잠금, Shared lock)을 설정하고 다른 세션에서 해당 레코드를 변경하지 못하게 한다. 물론 다른 세션에서 잠금이 걸린 레코드를 읽는 것은 가능하다.    
- FOR UPDATE: SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 건다.  
    -> 쓰기 잠금(배타 잠금, Exclusive lock)을 설정하고, 다른 트랜잭션에서는 그 레코드를 변경하는것 뿐만 아니라 읽기(FOR SHARE 절을 사용하는 SELECT 쿼리)도 수행할 수 없다.  

InnoDB에서는 테이블ㄹ에서 잠금 없는 읽기가 지원되기 때문에 특정 레코드가 잠겨진 상태라 하더라도 단순 SELECT 쿼리는 아무런 대기 없이 실행된다.  

```  
세션-1                                            세션-2
BEGIN;

SELECT *                                         
FROM employees
WHERE emp_no=10001 FOR UPDATE;


                                                SELECT *
                                                FROM employees
                                                WHERE emp_no=10001;
                                                => 잠금 대기 없이 즉시 결과 반환
```


```
세션-1                                            세션-2
BEGIN;

SELECT *                                         
FROM employees
WHERE emp_no=10001 FOR UPDATE;


                                                SELECT *
                                                FROM employees
                                                WHERE emp_no=10001 FOR SHARE;
                                                => 세션-1의 잠금을 기다림


COMMIT;
                                                => SELECT 쿼리 결과 반환                                                                    
```


