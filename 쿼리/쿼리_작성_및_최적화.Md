# ***쿼리 작성 및 최적화***  

## `BETWEEN`  

dept_no 테이블에는 인덱스가 존재한다(dept_no, emp_no)  

아래 쿼리는 dept_no가 'd003' 보다 같거나 크고 'd005' 보다 작거나 같은 `모든 인덱스의 범위를 검색해야 한다.`  
따라서 emp_no 조건은 비교 범위를 줄이는 역할을 하지 못한다.
```
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
```  

`In 쿼리는 동등 비교를 여러 번 수행`하는 것과 같은 효과가 있기 때문에 `인덱스를 최적으로 사용할 수 있다.`   
```
SELECT * FROM dept_emp
WHERE dept_no IN ('d003', 'd004', 'd005')
AND emp_no=1001;
```

MySQL 8.0 버전부터는 IN(subquery) 형태로 작성하면 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환해서 실행한다.  
```
SELECT *
FROM dept_emp 
WHERE dept_no IN (
    SELECT dept_no
    FROM departments
    WHERE dept_no BETWEEN 'd003' AND 'd005')
AND emp_no=10001;    
```

## `IN`
IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다.  
여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 떄문에 일반적으로 빠르게 처리된다.  

- 상수가 사용된 경우 - IN(?, ?, ?)
- 서브쿼리가 사용된 경우 - IN(SELECT ,, FROM ,,)  

하지만, `NOT IN 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없다.`  


## `시간조회`

`NOW(), SYSDATE()` 함수는 같은 기능인것 같지만, 동작 방식에서 큰 차이가 있다.  
하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만, SYSDATE() 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결과값이 다르다.  

  
이러한 경우 `인덱스를 효율적으로 사용하지 못한다.`  










